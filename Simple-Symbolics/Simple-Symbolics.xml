<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Simple-Symbolics</name></assembly>
<members>
<member name="M:MathNet.Symbolics.Utils.|Products|_|(MathNet.Symbolics.Expression)">
<summary>
(fx,var,start, stop)
</summary>
</member>
<member name="M:MathNet.Symbolics.Utils.defineStr(MathNet.Symbolics.Expression,MathNet.Symbolics.Expression,System.String)">
<summary>
Define with left, right and description
</summary>
</member>
<member name="M:MathNet.Symbolics.Utils.pdiff(MathNet.Symbolics.Expression,MathNet.Symbolics.Expression)">
<summary>
use partial differentiation Leibniz notation
</summary>
</member>
<member name="M:MathNet.Symbolics.Utils.diff(MathNet.Symbolics.Expression,MathNet.Symbolics.Expression)">
<summary>
wrap input expression in Leibniz notation for differentiation.
</summary>
</member>
<member name="M:MathNet.Symbolics.Utils.FunctionHelpers.fxn(System.String,MathNet.Symbolics.Expression,MathNet.Symbolics.Expression)">
<summary>
Create a function with parameter, body and name : fxn &quot;g&quot; x x^2 = `x |-&gt; x^2`
</summary>
</member>
<member name="M:MathNet.Symbolics.Utils.FunctionHelpers.fx2(MathNet.Symbolics.Expression,MathNet.Symbolics.Expression)">
<summary>
Create a function with parameter, body and default name &quot;f&quot;: fx2 x x^2 = `x |-&gt; x^2`
</summary>
</member>
<member name="M:MathNet.Symbolics.Utils.FunctionHelpers.fx(MathNet.Symbolics.Expression)">
<summary>
Create a function symbol with default name &quot;f&quot;: fx y = `f(y)`
</summary>
</member>
<member name="M:MathNet.Symbolics.Utils.FunctionHelpers.fn(System.String,MathNet.Symbolics.Expression)">
<summary>
Create a function symbol with name and parameter symbol `x`: fn &quot;g&quot; y = `g(y)`
</summary>
</member>
<member name="T:MathNet.Symbolics.Utils">
 <summary>
  Core Util functions.
 </summary>

 <namespacedoc>
   <summary>Extension to MathNet.Symbolics which allows for flexible descriptions of and computations on symbolic math expressions.</summary>

   <remarks>Simple Symbolics is a library built atop MathNet Symbolics. It is not meant to be a replacement for computer algebra systems. Such systems are largely automatic and quite heavyweight. This project intends to diverge a bit from typical CAS to look at what happens when you simply automate tedium and slightly augment a human? The manipulations are meant as much as possible to mirror what a human would do. The code can thus serve as a description of how humans typically approach these problems. Otherwise, it also provide tools that can be combined to do so. An example is indefinite integration. CAS systems can in instances give very unintuitive answers or otherwise fail to complete where a human could. Another difference is the intention to combine with basic logic programming and serve as a note taking tool when reading mathematical papers. This system will then augment the working memory for the reader but also (end goal) allow manipulation of some of the claims.</remarks>
 </namespacedoc>
</member>
<member name="M:MathNet.Symbolics.NumberProperties.BigRational.fromFloat(System.Double)">
<summary>
limited by range of decimal (which is used as a less noisy alternative to floats)
</summary>
</member>
<member name="M:MathNet.Symbolics.Equations.EquationModule.multiplyDenominatorsAndSubtract(MathNet.Symbolics.Equations.Equation)">
<summary>
convenience function that multiplies by denominator of right and left sides of equation and then subtracts right side ex : a/b = c /d -&gt; a * d = b * c -&gt; a * d - b * c = 0
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.applyfn(MathNet.Symbolics.Expression,MathNet.Symbolics.Expression)">
<summary>
Given a function expression, creates a function and then applies parameter. Best for single use.
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.funcOfExpr(MathNet.Symbolics.Expression,MathNet.Symbolics.Expression,MathNet.Symbolics.Expression)">
<summary>
Returns an F# function given a formula expression
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.toFunc(MathNet.Symbolics.Expression)">
<summary>
Given a function expression with a body, returns an F# function. See also
toFuncMV &lt;see cref=&quot;M:MathNet.Symbolics.Core.toFuncMV&quot;/&gt;
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.evalToDecimalFn(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},MathNet.Symbolics.Expression)">
<summary>
If the expression is a number converts to a float expression with f applied
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.evalToDecimal(MathNet.Symbolics.Expression)">
<summary>
If the expression is a number converts to a float expression instead of its symbolic form
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.Expression.evalExprToNumericOrNamedVars.Static(System.Collections.Generic.IEnumerable{System.Tuple{MathNet.Symbolics.Expression,MathNet.Symbolics.Expression}},MathNet.Symbolics.Expression)">
<summary>
eval with numbers or vars with the phrase &quot;Var&quot; in the symbol name are acceptable
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.Expression.evalExprToNumericOrVars.Static(Microsoft.FSharp.Core.FSharpFunc{System.String,System.Boolean},System.Collections.Generic.IEnumerable{System.Tuple{MathNet.Symbolics.Expression,MathNet.Symbolics.Expression}},MathNet.Symbolics.Expression)">
<summary>
eval with numbers or vars (optionally) are acceptable
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.Rational.partitionSumInNumerator(Microsoft.FSharp.Core.FSharpFunc{MathNet.Symbolics.Expression,System.Boolean},MathNet.Symbolics.Expression)">
<summary>
given a rational with a sum in the numerator, partitions into numerators for which f is true vs false. Eg (a+b+c)/x, returns (a+b)/x+c/x if f = ((=) c) as it splits for c only.
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.Rational.splitSumInNumerator(MathNet.Symbolics.Expression)">
<summary>
given (a+b)/x, returns a/x + b/x
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.Rational.applyToNumerator(Microsoft.FSharp.Core.FSharpFunc{MathNet.Symbolics.Expression,MathNet.Symbolics.Expression},MathNet.Symbolics.Expression)">
<summary>
Apply a function to the numerator of any rational whose denominator &lt;&gt; 1
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.Expression.extractNegativeOne(MathNet.Symbolics.Expression)">
<summary>
This rewrites the expression in terms of its negation, but multiplies it with -1 so as to keep it equal, effectively pulling out a -1. Useful for cancelling sometimes.
Example: -a - b becomes -1 * (a + b) = -(a+b).
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.Expression.cancelAbs(MathNet.Symbolics.Expression)">
<summary>
 condition: x &gt; 0
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.Structure.mapfirstNF(System.Int32,Microsoft.FSharp.Core.FSharpFunc{MathNet.Symbolics.Expression,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{MathNet.Symbolics.Expression,MathNet.Symbolics.Expression},MathNet.Symbolics.Expression)">
<summary>
Map the first N while also applying a filter
</summary>
</member>
<member name="M:MathNet.Symbolics.Logarithm.powerRuleReverse(MathNet.Symbolics.Expression)">
<summary>
a * log x -&gt; log(x^a)
</summary>
</member>
<member name="M:MathNet.Symbolics.Logarithm.powerRule(MathNet.Symbolics.Expression)">
<summary>
log (x**n) -&gt; n * log x
</summary>
</member>
<member name="M:MathNet.Symbolics.Logarithm.contract(MathNet.Symbolics.Expression)">
<summary>
log a + log b + ... -&gt; log (a*b...)
</summary>
</member>
<member name="M:MathNet.Symbolics.Logarithm.expand(MathNet.Symbolics.Expression)">
<summary>
log (a * b) -&gt; log a + log b
</summary>
</member>
<member name="M:MathNet.Symbolics.Summation.binomialTheorem(MathNet.Symbolics.Expression)">
<summary>
 condition: n &gt;= 0
</summary>
</member>
<member name="M:MathNet.Symbolics.Summation.simplifyInfiniteGeometricSum(MathNet.Symbolics.Expression)">
<summary>
 condition: r &lt;= 1, r &gt; 0
</summary>
</member>
<member name="P:MathNet.Symbolics.Summation.mergeSummationsInSum">
<summary>
merge summations in a sum that have the same parameters, eg Σ x + Σ y to Σ (x+y)
</summary>
</member>
<member name="M:MathNet.Symbolics.Summation.adjustSummationTo(MathNet.Symbolics.Expression,MathNet.Symbolics.Expression,MathNet.Symbolics.Expression,MathNet.Symbolics.Expression)">
<summary>
Adjusts summation to have a start, stop or var if it does not already
</summary>
</member>
<member name="P:MathNet.Symbolics.Differentiation.Dx">
<summary>
short-hand for evalDerivativeExprs which recursively evaluates all derivative notation expressions in expression.
</summary>
</member>
<member name="M:MathNet.Symbolics.Differentiation.D(MathNet.Symbolics.Expression,MathNet.Symbolics.Expression)">
<summary>
calculates (partial) derivative of given expression, compare with diff which wraps an expression in leibniz differentiation notation
</summary>
</member>
<member name="P:MathNet.Symbolics.Differentiation.evalDerivativeExprs">
<summary>
Recursively evaluates all derivative notation expressions in expression. see also Dx shorthand.
</summary>
</member>
<member name="M:MathNet.Symbolics.Differentiation.evalDerivative(MathNet.Symbolics.Expression)">
<summary>
Given an input expression that&apos;s a Leibniz notation expression of the derivative of a function, calculates its derivative.
</summary>
</member>
<member name="M:MathNet.Symbolics.Solving.Polynomial.factor(MathNet.Symbolics.Expression,MathNet.Symbolics.Expression)">
<summary>
The rational roots method to factor polynomials with rational roots with degree &gt; 2
</summary>
</member>
<member name="M:MathNet.Symbolics.Solving.Polynomial.toIntegerCoefficients(MathNet.Symbolics.Expression)">
<summary>
Returns Least Common multiple of denominator coefficients and polynomial with integer coefficients from multiplying by lcm
</summary>
</member>
<member name="T:MathNet.Symbolics.ProbabilityDistributions.Exponential">
<summary>
 the exponential distribution is the probability distribution of the time between events in a Poisson point process,
</summary>
</member>
<member name="M:MathNet.Symbolics.ProbabilityDistributions.Binomial.Prob(MathNet.Symbolics.Expression)">
<summary>
Probability of k Heads in n flips each with probability p
</summary>
</member>
<member name="T:MathNet.Symbolics.ProbabilityDistributions.Binomial">
<summary>
From wiki:binomal with distr with parameters n and p is the discrete probability distribution of the number of successes in a sequence of n independent experiments, each asking a yes–no question, and each with its own Boolean-valued outcome: success/yes/true/one (with probability p)
</summary>
</member>
</members>
</doc>
