<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Simple-Symbolics</name></assembly>
<members>
<member name="M:Equations.EquationModule.multiplyDenominatorsAndSubtract(Equations.Equation)">
<summary>
convenience function that multiplies by denominator of right and left sides of equation and then subtracts right side ex : a/b = c /d -&gt; a * d = b * c -&gt; a * d - b * c = 0
</summary>
</member>
<member name="T:ProbabilityDistributions.Exponential">
<summary>
 the exponential distribution is the probability distribution of the time between events in a Poisson point process,
</summary>
</member>
<member name="M:ProbabilityDistributions.Binomial.Prob(MathNet.Symbolics.Expression)">
<summary>
Probability of k Heads in n flips each with probability p
</summary>
</member>
<member name="T:ProbabilityDistributions.Binomial">
<summary>
From wiki:binomal with distr with parameters n and p is the discrete probability distribution of the number of successes in a sequence of n independent experiments, each asking a yes–no question, and each with its own Boolean-valued outcome: success/yes/true/one (with probability p)
</summary>
</member>
<member name="M:MathNet.Symbolics.Utils.|Products|_|(MathNet.Symbolics.Expression)">
<summary>
(fx,var,start, stop)
</summary>
</member>
<member name="M:MathNet.Symbolics.Utils.defineStr(MathNet.Symbolics.Expression,MathNet.Symbolics.Expression,System.String)">
<summary>
Define with left, right and description
</summary>
</member>
<member name="M:MathNet.Symbolics.Utils.FunctionHelpers.fn(MathNet.Symbolics.Expression,MathNet.Symbolics.Expression)">
<summary>
Create a function with symbol, body and default name &quot;f&quot;: fn x x^2 = `x |-&gt; x^2`
</summary>
</member>
<member name="M:MathNet.Symbolics.Utils.FunctionHelpers.fx(MathNet.Symbolics.Expression)">
<summary>
Create a function with symbol and default name &quot;f&quot;: fx y = `f(y)`
</summary>
</member>
<member name="M:MathNet.Symbolics.Utils.FunctionHelpers.func(System.String,MathNet.Symbolics.Expression)">
<summary>
Create a function with name and symbol: func &quot;g&quot; y = `g(y)`
</summary>
</member>
<member name="T:MathNet.Symbolics.Utils">
 <summary>
   A module
 </summary>

 <namespacedoc>
   <summary>A namespace to remember</summary>

   <remarks>More on that</remarks>
 </namespacedoc>
</member>
<member name="M:MathNet.Symbolics.NumberProperties.BigRational.fromFloat(System.Double)">
<summary>
limited by range of decimal (which is used as a less noisy alternative to floats)
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.applyfn(MathNet.Symbolics.Expression,MathNet.Symbolics.Expression)">
<summary>
Given a function expression, creates a function and then applies parameter. Best for single use.
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.makefuncOfExpr(MathNet.Symbolics.Expression,MathNet.Symbolics.Expression,MathNet.Symbolics.Expression)">
<summary>
Returns a function given a formula
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.makefunc(MathNet.Symbolics.Expression)">
<summary>
Given a function expression with a body, returns an F# function. See also
makeFuncMV &lt;see cref=&quot;M:MathNet.Symbolics.Core.makefuncMV&quot;/&gt;
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.evalToDecimalFn(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},MathNet.Symbolics.Expression)">
<summary>
If the expression is a number converts to a float expression with f applied
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.evalToDecimal(MathNet.Symbolics.Expression)">
<summary>
If the expression is a number converts to a float expression instead of its symbolic form
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.Expression.evalExprToNumericOrNamedVars.Static(System.Collections.Generic.IEnumerable{System.Tuple{MathNet.Symbolics.Expression,MathNet.Symbolics.Expression}},MathNet.Symbolics.Expression)">
<summary>
eval with numbers or vars with the phrase &quot;Var&quot; in the symbol name are acceptable
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.Expression.evalExprToNumericOrVars.Static(Microsoft.FSharp.Core.FSharpFunc{System.String,System.Boolean},System.Collections.Generic.IEnumerable{System.Tuple{MathNet.Symbolics.Expression,MathNet.Symbolics.Expression}},MathNet.Symbolics.Expression)">
<summary>
eval with numbers or vars (optionally) are acceptable
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.Rational.partitionSumInNumerator(Microsoft.FSharp.Core.FSharpFunc{MathNet.Symbolics.Expression,System.Boolean},MathNet.Symbolics.Expression)">
<summary>
given a rational with a sum in the numerator, partitions into numerators for which f is true vs false. Eg (a+b+c)/x, returns (a+b)/x+c/x if f = ((=) c) as it splits for c only.
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.Rational.splitSumInNumerator(MathNet.Symbolics.Expression)">
<summary>
given (a+b)/x, returns a/x + b/x
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.Rational.applyToNumerator(Microsoft.FSharp.Core.FSharpFunc{MathNet.Symbolics.Expression,MathNet.Symbolics.Expression},MathNet.Symbolics.Expression)">
<summary>
Apply a function to the numerator of any rational whose denominator &lt;&gt; 1
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.Expression.extractNegativeOne(MathNet.Symbolics.Expression)">
<summary>
This rewrites the expression in terms of its negation, but multiplies it with -1 so as to keep it equal, effectively pulling out a -1. Useful for cancelling sometimes.
Example: -a - b becomes -1 * (a + b) = -(a+b).
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.Expression.cancelAbs(MathNet.Symbolics.Expression)">
<summary>
 condition: x &gt; 0
</summary>
</member>
<member name="M:MathNet.Symbolics.Core.Structure.mapfirstNF(System.Int32,Microsoft.FSharp.Core.FSharpFunc{MathNet.Symbolics.Expression,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{MathNet.Symbolics.Expression,MathNet.Symbolics.Expression},MathNet.Symbolics.Expression)">
<summary>
Map the first N while also applying a filter
</summary>
</member>
<member name="M:MathNet.Symbolics.Logarithm.powerRuleReverse(MathNet.Symbolics.Expression)">
<summary>
a * log x -&gt; log(x^a)
</summary>
</member>
<member name="M:MathNet.Symbolics.Logarithm.powerRule(MathNet.Symbolics.Expression)">
<summary>
log (x**n) -&gt; n * log x
</summary>
</member>
<member name="M:MathNet.Symbolics.Logarithm.contract(MathNet.Symbolics.Expression)">
<summary>
log a + log b + ... -&gt; log (a*b...)
</summary>
</member>
<member name="M:MathNet.Symbolics.Logarithm.expand(MathNet.Symbolics.Expression)">
<summary>
log (a * b) -&gt; log a + log b
</summary>
</member>
<member name="M:MathNet.Symbolics.Summation.binomialTheorem(MathNet.Symbolics.Expression)">
<summary>
 condition: n &gt;= 0
</summary>
</member>
<member name="M:MathNet.Symbolics.Summation.simplifyInfiniteGeometricSum(MathNet.Symbolics.Expression)">
<summary>
 condition: r &lt;= 1, r &gt; 0
</summary>
</member>
<member name="P:MathNet.Symbolics.Summation.mergeSummationsInSum">
<summary>
merge summations in a sum that have the same parameters, eg Σ x + Σ y to Σ (x+y)
</summary>
</member>
<member name="M:MathNet.Symbolics.Summation.adjustSummationTo(MathNet.Symbolics.Expression,MathNet.Symbolics.Expression,MathNet.Symbolics.Expression,MathNet.Symbolics.Expression)">
<summary>
Adjusts summation to have a start, stop or var if it does not already
</summary>
</member>
<member name="M:MathNet.Symbolics.Solving.Polynomial.factor(MathNet.Symbolics.Expression,MathNet.Symbolics.Expression)">
<summary>
The rational roots method to factor polynomials with rational roots with degree &gt; 2
</summary>
</member>
<member name="M:MathNet.Symbolics.Solving.Polynomial.toIntegerCoefficients(MathNet.Symbolics.Expression)">
<summary>
Returns Least Common multiple of denominator coefficients and polynomial with integer coefficients from multiplying by lcm
</summary>
</member>
</members>
</doc>
